<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Pixel Morph — reversible </title>
<style>
  :root{color-scheme:dark}
  body{margin:0;background:#0b0b10;color:#e8e8f0;font:14px/1.4 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  header{padding:14px 18px;border-bottom:1px solid #20202a;display:flex;gap:10px;align-items:center}
  header h1{margin:0;font-size:16px;font-weight:700;letter-spacing:.2px}
  .toolbar{display:flex;gap:12px;align-items:flex-end;flex-wrap:wrap;padding:12px 16px;border-bottom:1px solid #20202a;background:#0f1017}
  .control{display:flex;flex-direction:column;gap:6px;min-width:180px}
  .control label{font-size:12px;opacity:.9}
  input[type=file],input[type=text],input[type=number],input[type=password],select{background:#0e0f15;border:1px solid #2a2b36;color:#e8e8f0;border-radius:10px;padding:8px 10px}
  input[type=color]{background:#0e0f15;border:1px solid #2a2b36;border-radius:10px;height:36px}
  input[type=range]{accent-color:#7aa2ff}
  .btn{background:#2a2f4a;border:1px solid #3b4160;color:#fff;border-radius:12px;padding:10px 12px;cursor:pointer;user-select:none}
  .btn:hover{background:#33406a}
  .btn.secondary{background:#1d2236}
  .btn.danger{background:#472b2b;border-color:#6b3a3a}
  .sep{width:1px;height:42px;background:#1f2030;margin:0 2px}
  .analyzer{display:flex;gap:10px;align-items:flex-end;flex-wrap:wrap;padding:10px 16px;border-bottom:1px solid #20202a;background:#0f1017}
  .pill{display:inline-block;padding:4px 8px;border:1px solid #2a2b36;border-radius:999px;background:#121324;font-size:12px}
  .stage{padding:14px 16px}
  .grid{display:grid;gap:12px}
  @media (min-width:900px){ .grid{grid-template-columns:repeat(3,1fr)} }
  .card{background:#11121a;border:1px solid #1d1e28;border-radius:16px;padding:10px}
  .card .title{font-size:12px;opacity:.8;margin-bottom:8px}
  canvas{width:100%;height:auto;background:#0c0c12;border-radius:12px;border:1px solid #1a1b24}
  .statbar{padding:10px 16px;border-top:1px solid #20202a;display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;font-size:12px;opacity:.95}
  .muted{opacity:.85}
  .progress{padding:10px 16px}
  progress{width:100%;height:10px}
  .row{display:flex;gap:8px;align-items:center}
  .nowrap{white-space:nowrap}
  .hidden{display:none}
  .hint{font-size:10px;opacity:.65;margin-left:6px;letter-spacing:.2px;border:1px solid #2a2b36;padding:1px 4px;border-radius:6px}
  .iconbtn{background:#1a1c29;border:1px solid #2a2b36;color:#e8e8f0;border-radius:10px;padding:6px 10px;cursor:pointer}
  .iconbtn:hover{background:#22263a}
</style>
</head>
<body>
<header><h1>Pixel Morph — reposition only</h1><button id="helpBtn" class="iconbtn" title="How to use (H)">?</button></header>

<!-- ====== TOP TOOLBAR ====== -->
<section class="toolbar">
  <div class="control">
    <label>Source <sup class="hint">RGB</sup></label>
    <input id="srcFile" type="file" accept="image/*">
    <div class="row"><button class="btn secondary" id="clearSrcBtn">Clear</button></div>
  </div>

  <div class="control">
    <label>Target <sup class="hint">layout</sup></label>
    <input id="tgtFile" type="file" accept="image/*">
    <div class="row"><button class="btn secondary" id="clearTgtBtn">Clear</button></div>
  </div>

  <div class="control">
    <label>Password</label>
    <input id="pw" type="password" placeholder="••••••••">
  </div>

  <div class="control">
    <label>Guide Mode <sup class="hint">ordering</sup></label>
    <select id="mode">
      <option value="tone">Tone (brightness + edges)</option>
      <option value="mask">Mask (white/black + threshold)</option>
    </select>
  </div>

  <div class="control" id="maskCtl" style="display:none">
    <label>Mask Color <sup class="hint">polarity</sup></label>
    <select id="maskColor">
      <option value="white">White is shape</option>
      <option value="black">Black is shape</option>
    </select>
  </div>
  <div class="control" id="thrCtl" style="display:none; min-width:230px">
    <label>Threshold <sup class="hint">τ</sup> <span id="thrVal" class="pill">128</span></label>
    <input id="thr" type="range" min="0" max="255" value="128">
  </div>

  <div class="control">
    <label>Canvas From <sup class="hint">base</sup></label>
    <select id="base">
      <option value="source">Source defines canvas</option>
      <option value="target">Target defines canvas</option>
    </select>
  </div>

  <div class="control">
    <label>Fit <sup class="hint">contain/cover</sup></label>
    <select id="fit">
      <option value="contain">Contain (letterbox)</option>
      <option value="cover">Cover (crop)</option>
      <option value="stretch">Stretch</option>
    </select>
  </div>

  <div class="control" id="lbCtl">
    <label>Letterbox <sup class="hint">bg</sup></label>
    <input id="lbColor" type="color" value="#000000">
  </div>

  <div class="control" style="min-width:140px">
    <label>Max Side <sup class="hint">downscale</sup></label>
    <input id="maxSide" type="number" value="900" min="64" step="10">
  </div>

  <div class="sep"></div>

  <div class="control" style="min-width:220px">
    <button class="btn" id="previewBtn">Preview</button>
    <button class="btn" id="encodeBtn" title="Embed encrypted mapping + download PNG">Encode & Download</button>
    <button class="btn danger" id="resetBtn" title="Clear all state">Reset All</button>
  </div>

  <div class="sep"></div>

  <div class="control" style="min-width:280px">
    <label>Decode <sup class="hint">recover</sup></label>
    <input id="decFile" type="file" accept="image/png">
    <div class="row">
      <input id="decPw" type="password" placeholder="password">
      <button class="btn secondary nowrap" id="previewDecBtn">Preview Decode</button>
    </div>
    <div class="row">
      <button class="btn hidden" id="downloadDecBtn">Download Recovered</button>
    </div>
  </div>

  <div class="sep"></div>

  <div class="control" style="min-width:140px">
    <label>Swap Roles <sup class="hint">⇆</sup></label>
    <div class="row"><button class="btn" id="swapBtn" title="Swap Source ⇄ Target (X)">↔ Swap</button></div>
    <label class="row" style="gap:6px"><input type="checkbox" id="flipBase"> Flip Output base too</label>
  </div>
</section>

<!-- ====== ANALYZER ====== -->
<section class="analyzer">
  <div class="control" style="min-width:220px">
    <label>Payload Limit <sup class="hint">MB</sup></label>
    <input id="payloadLimit" type="number" value="16" min="2" step="2">
  </div>
  <div class="control" style="min-width:220px">
    <label>Recommend Size <sup class="hint">analyze</sup></label>
    <button class="btn" id="analyzeBtn">Analyze</button>
  </div>
  <div class="control" style="min-width:360px">
    <label>Report <sup class="hint">calc</sup></label>
    <div id="analysis" class="muted">Load Source & Target, then Analyze.</div>
  </div>
</section>

<!-- ====== PREVIEWS ====== -->
<section class="stage">
  <div class="grid">
    <div class="card">
      <div class="title">Source <sup class="hint">RGB</sup></div>
      <canvas id="srcCanvas"></canvas>
    </div>
    <div class="card">
      <div class="title">Target <sup class="hint">fitted</sup></div>
      <canvas id="tgtCanvas"></canvas>
    </div>
    <div class="card">
      <div class="title">Preview <sup class="hint">morph</sup></div>
      <canvas id="outCanvas"></canvas>
    </div>
  </div>
</section>

<!-- ====== PROGRESS / STATUS ====== -->
<div class="progress">
  <progress id="prog" value="0" max="1"></progress>
  <div class="row" style="justify-content:space-between">
    <div id="progLabel" class="muted">Idle</div>
    <div id="eta" class="muted"></div>
  </div>
</div>

<div class="statbar">
  <div id="infoLeft">Pick Source & Target to begin.</div>
  <div id="infoRight" class="muted"></div>
</div>

<script>
/* ---------- state ---------- */
let running=false, jobToken=0, lastRecoveredBlob=null;
// non-destructive caches so we can swap without touching the <input type=file>
let srcBlob=null, tgtBlob=null; // File or Blob references

/* ---------- elements ---------- */
const $ = s => document.querySelector(s);
const srcFile=$('#srcFile'), tgtFile=$('#tgtFile'), decFile=$('#decFile');
const pw=$('#pw'), decPw=$('#decPw');
const modeSel=$('#mode'), maskCtl=$('#maskCtl'), thrCtl=$('#thrCtl');
const maskColorSel=$('#maskColor'), thr=$('#thr'), thrVal=$('#thrVal');
const baseSel=$('#base'), fitSel=$('#fit'), lbCtl=$('#lbCtl'), lbColor=$('#lbColor');
const maxSideInp=$('#maxSide'), payloadLimitInp=$('#payloadLimit');
const srcC=$('#srcCanvas'), tgtC=$('#tgtCanvas'), outC=$('#outCanvas');
const previewBtn=$('#previewBtn'), encodeBtn=$('#encodeBtn'), resetBtn=$('#resetBtn');
const previewDecBtn=$('#previewDecBtn'), downloadDecBtn=$('#downloadDecBtn');
const clearSrcBtn=$('#clearSrcBtn'), clearTgtBtn=$('#clearTgtBtn');
const analyzeBtn=$('#analyzeBtn'), analysis=$('#analysis');
const infoL=$('#infoLeft'), infoR=$('#infoRight');
const prog=$('#prog'), progLabel=$('#progLabel'), eta=$('#eta');
const swapBtn=$('#swapBtn'), flipBaseChk=$('#flipBase');

/* ---------- UI toggles ---------- */
modeSel.addEventListener('change',()=>{const m=modeSel.value==='mask';maskCtl.style.display=m?'':'none';thrCtl.style.display=m?'':'none'; scheduleAutoPreview();});
thr.addEventListener('input',()=>{thrVal.textContent=thr.value; scheduleAutoPreview(200);});
fitSel.addEventListener('change',()=>{lbCtl.style.display=(fitSel.value==='contain')?'':'none'; scheduleAutoPreview();});
baseSel.addEventListener('change',()=>{scheduleAutoPreview();});
maxSideInp.addEventListener('change',()=>{scheduleAutoPreview();});

/* ---------- reset / clear ---------- */
function resetCanvases(){[srcC,tgtC,outC].forEach(c=>{c.width=1;c.height=1;c.getContext('2d').clearRect(0,0,1,1);});}
function clearSrc(){srcFile.value=''; srcBlob=null; resetCanvases(); infoL.textContent='Source cleared.'; infoR.textContent='';}
function clearTgt(){tgtFile.value=''; tgtBlob=null; resetCanvases(); infoL.textContent='Target cleared.'; infoR.textContent='';}
function resetAll(){ if(running) return; jobToken++; srcFile.value=''; tgtFile.value=''; decFile.value=''; srcBlob=null; tgtBlob=null; pw.value=''; decPw.value='';
  maxSideInp.value=900; modeSel.value='tone'; thr.value=128; thrVal.textContent='128'; maskColorSel.value='white';
  baseSel.value='source'; fitSel.value='contain'; lbColor.value='#000000'; lbCtl.style.display=''; maskCtl.style.display='none'; thrCtl.style.display='none';
  lastRecoveredBlob=null; setProgress(0,'Idle'); setETA(0); analysis.textContent='Load Source & Target, then Analyze.'; resetCanvases();
  infoL.textContent='Reset complete. Pick Source & Target to begin.'; infoR.textContent='';}
clearSrcBtn.addEventListener('click',clearSrc); clearTgtBtn.addEventListener('click',clearTgt); resetBtn.addEventListener('click',resetAll);

/* ---------- progress ---------- */
function setProgress(p,label){prog.value=p; progLabel.textContent=label||'';}
function setETA(sec){ if(!sec||!isFinite(sec)||sec<=0){eta.textContent='';return;} const m=Math.floor(sec/60), s=Math.round(sec%60); eta.textContent=m>0?`~${m}m ${s}s left`:`~${s}s left`;}

/* ---------- image I/O ---------- */
function loadImageViaReader(file){return new Promise((resolve,reject)=>{const fr=new FileReader();fr.onload=()=>{const img=new Image();img.onload=()=>resolve(img);img.onerror=reject;img.src=fr.result;};fr.onerror=reject;fr.readAsDataURL(file);});}

/* draw image with fit into a given canvas size */
function drawImageFitToCanvas(img, canvas, W, H, mode='contain', letterbox='#000000'){
  canvas.width=W; canvas.height=H;
  const ctx=canvas.getContext('2d');
  ctx.save();
  ctx.fillStyle=letterbox; ctx.fillRect(0,0,W,H);
  const iw=img.naturalWidth, ih=img.naturalHeight;
  if(mode==='stretch'){ ctx.drawImage(img,0,0,W,H); ctx.restore(); return; }
  const sr = iw/ih, dr = W/H;
  if(mode==='contain'){
    const scale = (sr>dr) ? (W/iw) : (H/ih);
    const w = Math.round(iw*scale), h = Math.round(ih*scale);
    const x = Math.floor((W-w)/2), y = Math.floor((H-h)/2);
    ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality='high';
    ctx.drawImage(img, x,y, w,h);
  } else { // cover
    const scale = (sr>dr) ? (H/ih) : (W/iw);
    const w = Math.round(iw*scale), h = Math.round(ih*scale);
    const x = Math.floor((W-w)/2), y = Math.floor((H-h)/2);
    ctx.imageSmoothingEnabled = true; ctx.imageSmoothingQuality='high';
    ctx.drawImage(img, x,y, w,h);
  }
  ctx.restore();
}

/* helper: resolve which files to use (cached swap-aware) */
function currentSrcFile(){ return srcBlob || (srcFile.files && srcFile.files[0]) || null; }
function currentTgtFile(){ return tgtBlob || (tgtFile.files && tgtFile.files[0]) || null; }

/* decide the unified output size and draw both images accordingly */
async function drawPairToWorkingCanvases(maxSide){
  const sFile=currentSrcFile(), tFile=currentTgtFile();
  if(!sFile||!tFile) throw new Error('Pick Source & Target.');
  const srcImg = await loadImageViaReader(sFile);
  const tgtImg = await loadImageViaReader(tFile);

  // base decides raw working size (before MaxSide downscale)
  let baseW, baseH;
  if(baseSel.value==='source'){ baseW=srcImg.naturalWidth; baseH=srcImg.naturalHeight; }
  else { baseW=tgtImg.naturalWidth; baseH=tgtImg.naturalHeight; }

  // downscale to MaxSide
  const s = Math.min(1, maxSide / Math.max(baseW, baseH));
  const W = Math.max(1, Math.round(baseW*s)), H = Math.max(1, Math.round(baseH*s));

  // source forms the true color field grid
  drawImageFitToCanvas(srcImg, srcC, W,H, 'stretch');
  // target respected fit relative to same W×H
  drawImageFitToCanvas(tgtImg, tgtC, W,H, fitSel.value, lbColor.value);

  return {W,H, srcImg, tgtImg};
}

function getImageData(canvas){ return canvas.getContext('2d').getImageData(0,0,canvas.width, canvas.height); }
function putImageDataRGB(canvas, rgbFlat, w, h){ canvas.width=w; canvas.height=h; const ctx=canvas.getContext('2d'); const out=ctx.createImageData(w,h);
  for(let i=0,j=0;i<rgbFlat.length;i+=3,j+=4){ out.data[j]=rgbFlat[i]; out.data[j+1]=rgbFlat[i+1]; out.data[j+2]=rgbFlat[i+2]; out.data[j+3]=255; }
  ctx.putImageData(out,0,0); }

/* ---------- ordering ---------- */
function interleave16(x){x&=0xFFFF;x=(x|(x<<8))&0x00FF00FF;x=(x|(x<<4))&0x0F0F0F0F;x=(x|(x<<2))&0x33333333;x=(x|(x<<1))&0x55555555;return x;}
function mortonKey(x,y){return (interleave16(x)<<1)|interleave16(y);} 
function sortCoordsMorton(w,h){const coords=new Array(w*h);for(let y=0,i=0;y<h;y++)for(let x=0;x<w;x++,i++)coords[i]=[x,y];const order=coords.map(([x,y],i)=>[mortonKey(x,y),i]).sort((a,b)=>a[0]-b[0]).map(p=>p[1]);return order.map(i=>coords[i]);}
function destOrderTone(gray,w,h){const score=new Float32Array(w*h);for(let i=0;i<w*h;i++)score[i]=gray[i];const idx=(x,y)=>y*w+x;
  for(let y=1;y<h-1;y++)for(let x=1;x<w-1;x++){const gx=-gray[idx(x-1,y-1)]-2*gray[idx(x-1,y)]-gray[idx(x-1,y+1)]+gray[idx(x+1,y-1)]+2*gray[idx(x+1,y)]+gray[idx(x+1,y+1)];
    const gy=-gray[idx(x-1,y-1)]-2*gray[idx(x,y-1)]-gray[idx(x+1,y-1)]+gray[idx(x-1,y+1)]+2*gray[idx(x,y+1)]+gray[idx(x+1,y+1)];
    const mag=Math.min(255,Math.abs(gx)+Math.abs(gy)); score[idx(x,y)]=0.85*score[idx(x,y)]+0.15*mag;}
  const order=Array.from(score,(v,i)=>[v,i]).sort((a,b)=>b[0]-a[0]).map(p=>p[1]); return order.map(i=>[i%w,(i/w)|0]);}
function destOrderMask(gray,w,h,whiteIsShape,thr){const on=[],off=[];for(let y=0;y<h;y++)for(let x=0;x<w;x++){const v=gray[y*w+x];(whiteIsShape?v>thr:v<thr)?on.push([x,y]):off.push([x,y]);}
  const mortSort=arr=>arr.map(([x,y],i)=>[mortonKey(x,y),i]).sort((a,b)=>a[0]-b[0]).map(p=>arr[p[1]]); return mortSort(on).concat(mortSort(off));}

/* ---------- morph (chunked, cancellable) ---------- */
async function buildMorphChunked(srcRGBA, tgtRGBA, w, h, mode, maskColor, threshold, token){
  const N=w*h, srcRGB=new Uint8Array(N*3); for(let i=0,j=0;i<N*4;i+=4,j+=3){srcRGB[j]=srcRGBA[i];srcRGB[j+1]=srcRGBA[i+1];srcRGB[j+2]=srcRGBA[i+2];}
  const gray=new Uint8Array(N); for(let i=0,j=0;i<N*4;i+=4,j++){gray[j]=(0.299*tgtRGBA[i]+0.587*tgtRGBA[i+1]+0.114*tgtRGBA[i+2])|0;}
  setProgress(0.05,'Building orders…'); setETA(0);
  const srcSorted=sortCoordsMorton(w,h); if(token.cancelled) throw new Error('cancelled');
  const destSorted=(mode==='tone')?destOrderTone(gray,w,h):destOrderMask(gray,w,h, maskColor==='white', Number(threshold));
  const mapping=new Uint32Array(N), permuted=new Uint8Array(N*3);
  const CHUNK=Math.max(50_000, Math.floor(N/40)); const t0=performance.now();
  for(let i=0;i<N;i+=CHUNK){
    if(token.cancelled) throw new Error('cancelled');
    const end=Math.min(N,i+CHUNK);
    for(let k=i;k<end;k++){const[sx,sy]=srcSorted[k], sIdx=(sy*w+sx)*3; const[dx,dy]=destSorted[k], dLin=dy*w+dx, dIdx=dLin*3;
      mapping[k]=dLin; permuted[dIdx]=srcRGB[sIdx]; permuted[dIdx+1]=srcRGB[sIdx+1]; permuted[dIdx+2]=srcRGB[sIdx+2];}
    const p=0.05+0.90*((end)/N), elapsed=(performance.now()-t0)/1000, remain=elapsed*(N-end)/(end-i||1); setProgress(p,'Repositioning pixels…'); setETA(remain);
    await new Promise(r=>setTimeout(r,0));
  }
  setProgress(1,'Done'); setETA(0);
  return {mapping, permuted};
}

/* ---------- crypto ---------- */
async function deriveKey(password, salt, iters=250000){const enc=new TextEncoder();const base=await crypto.subtle.importKey('raw',enc.encode(password),'PBKDF2',false,['deriveKey']);
  return crypto.subtle.deriveKey({name:'PBKDF2',hash:'SHA-256',salt,iterations:iters},base,{name:'AES-GCM',length:256},false,['encrypt','decrypt']);}
async function aeadEncrypt(key, iv, u8){const ct=await crypto.subtle.encrypt({name:'AES-GCM',iv},key,u8);return new Uint8Array(ct);} 
async function aeadDecrypt(key, iv, u8){const pt=await crypto.subtle.decrypt({name:'AES-GCM',iv},key,u8);return new Uint8Array(pt);} 

/* ---------- PNG helpers ---------- */
async function canvasToPNGBytes(canvas){const blob=await new Promise(r=>canvas.toBlob(r,'image/png'));return new Uint8Array(await blob.arrayBuffer());}
function crc32(bytes){let c=~0>>>0;for(let i=0;i<bytes.length;i++){c^=bytes[i];for(let k=0;k<8;k++)c=(c>>>1)^(0xEDB88320&(-(c&1)));}return (~c)>>>0;}
function insertPNGChunk(pngBytes,type4,data){let i=8,iend=-1;while(i+8<=pngBytes.length){const len=(pngBytes[i]<<24)|(pngBytes[i+1]<<16)|(pngBytes[i+2]<<8)|pngBytes[i+3];const t=pngBytes.slice(i+4,i+8);const next=i+8+len+4;if(t[0]===73&&t[1]===69&&t[2]===78&&t[3]===68){iend=i;break}i=next}
  if(iend<0)iend=pngBytes.length;const typeBytes=new TextEncoder().encode(type4);const lenBuf=new Uint8Array(4);new DataView(lenBuf.buffer).setUint32(0,data.length);
  const crcBuf=new Uint8Array(4);new DataView(crcBuf.buffer).setUint32(0,crc32(new Uint8Array([...typeBytes,...data])));return new Uint8Array([...pngBytes.slice(0,iend),...lenBuf,...typeBytes,...data,...crcBuf,...pngBytes.slice(iend)]);} 
function extractPNGChunk(pngBytes,type4){const tB=new TextEncoder().encode(type4);let i=8;while(i+8<=pngBytes.length){const len=(pngBytes[i]<<24)|(pngBytes[i+1]<<16)|(pngBytes[i+2]<<8)|pngBytes[i+3];const t=pngBytes.slice(i+4,i+8);const start=i+8,end=start+len,next=end+4;
  if(t[0]===tB[0]&&t[1]===tB[1]&&t[2]===tB[2]&&t[3]===tB[3])return pngBytes.slice(start,end);i=next}return null}

/* ---------- preview / encode ---------- */
async function doPreview(){
  if(running) return; running=true; const token={cancelled:false}; jobToken++;
  try{
    const maxSide=Number(maxSideInp.value||900);
    const {W,H}=await drawPairToWorkingCanvases(maxSide);
    const sDat=getImageData(srcC).data, tDat=getImageData(tgtC).data;
    setProgress(0,'Preparing…'); setETA(0);
    const {mapping,permuted}=await buildMorphChunked(sDat,tDat,W,H,modeSel.value,maskColorSel.value,thr.value,token);
    putImageDataRGB(outC,permuted,W,H);
    const N=W*H; infoL.textContent=`Preview • ${W}×${H} (${N.toLocaleString()} px)`; infoR.textContent=`Est. encrypted payload ≈ ${(N*4/1024|0)} KB`;
  } catch(e){ if(e.message!=='cancelled') infoL.textContent='Preview error: '+e.message; }
  finally{ setProgress(0,'Idle'); setETA(0); running=false; }
}
async function doEncode(){
  if(running) return; if(!pw.value){ infoL.textContent='Enter a password.'; return; }
  running=true; const token={cancelled:false}; jobToken++;
  try{
    const maxSide=Number(maxSideInp.value||900);
    const {W,H}=await drawPairToWorkingCanvases(maxSide);
    const sDat=getImageData(srcC).data, tDat=getImageData(tgtC).data;
    const {mapping,permuted}=await buildMorphChunked(sDat,tDat,W,H,modeSel.value,maskColorSel.value,thr.value,token);
    putImageDataRGB(outC,permuted,W,H);

    const salt=crypto.getRandomValues(new Uint8Array(16)); const iv=crypto.getRandomValues(new Uint8Array(12));
    const key=await deriveKey(pw.value,salt);
    setProgress(0.2,'Encrypting mapping…'); const mapBytes=new Uint8Array(mapping.buffer); const ct=await aeadEncrypt(key,iv,mapBytes);

    setProgress(0.9,'Packaging PNG…'); const png=await canvasToPNGBytes(outC);
    const payload=new Uint8Array(4+1+16+12+4+ct.length);
    payload.set(new TextEncoder().encode('PBK1'),0); payload[4]=2; payload.set(salt,5); payload.set(iv,21);
    new DataView(payload.buffer).setUint32(33,ct.length); payload.set(ct,37);
    const withChunk=insertPNGChunk(png,'rNdX',payload);
    const blob=new Blob([withChunk],{type:'image/png'}); const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='camo.png'; a.click();

    const N=W*H; infoL.textContent=`Encoded camo.png • ${W}×${H} (${N.toLocaleString()} px)`; infoR.textContent=`Encrypted payload ${ct.length.toLocaleString()} bytes`;
  } catch(e){ if(e.message!=='cancelled') infoL.textContent='Encode error: '+e.message; }
  finally{ setProgress(0,'Idle'); setETA(0); running=false; }
}

/* ---------- decode ---------- */
lastRecoveredBlob=null;
async function doPreviewDecode(){
  if(running) return; running=true; jobToken++; downloadDecBtn.classList.add('hidden'); lastRecoveredBlob=null;
  try{
    if(!decFile.files[0]){ infoL.textContent='Pick camo PNG first.'; return; }
    if(!decPw.value){ infoL.textContent='Enter password to decode.'; return; }
    setProgress(0.1,'Reading PNG…'); const bytes=new Uint8Array(await decFile.files[0].arrayBuffer());
    const chunk=extractPNGChunk(bytes,'rNdX'); if(!chunk){ infoL.textContent='No embedded payload found (rNdX).'; return; }
    const salt=chunk.slice(5,21), iv=chunk.slice(21,33); const clen=new DataView(chunk.buffer,chunk.byteOffset+33,4).getUint32(0); const ct=chunk.slice(37,37+clen);
    setProgress(0.25,'Deriving key…'); const key=await deriveKey(decPw.value,salt);
    setProgress(0.35,'Decrypting…'); let mapBytes; try{ mapBytes=await aeadDecrypt(key,iv,ct);}catch{ infoL.textContent='Decryption failed.'; return; }

    const img=await loadImageViaReader(decFile.files[0]); const W=img.naturalWidth, H=img.naturalHeight, N=W*H;
    outC.width=W; outC.height=H; outC.getContext('2d').drawImage(img,0,0,W,H); const perm=outC.getContext('2d').getImageData(0,0,W,H).data;
    const mapping=new Uint32Array(mapBytes.buffer,mapBytes.byteOffset,Math.floor(mapBytes.byteLength/4)); if(mapping.length!==N){ infoL.textContent='Mapping/image size mismatch.'; return; }

    setProgress(0.5,'Reconstructing…'); const srcSorted=sortCoordsMorton(W,H); const recSorted=new Uint8Array(N*3);
    const CHUNK=Math.max(50_000,Math.floor(N/40)); const t0=performance.now();
    for(let i=0;i<N;i+=CHUNK){ const end=Math.min(N,i+CHUNK);
      for(let k=i;k<end;k++){ const d=mapping[k]*4, j=k*3; recSorted[j]=perm[d]; recSorted[j+1]=perm[d+1]; recSorted[j+2]=perm[d+2]; }
      const p=0.5+0.45*((end)/N), elapsed=(performance.now()-t0)/1000, remain=elapsed*(N-end)/(end-i||1); setProgress(p,'Reconstructing…'); setETA(remain);
      await new Promise(r=>setTimeout(r,0)); }
    const outFlat=new Uint8Array(N*3); for(let i=0;i<N;i++){ const[sx,sy]=srcSorted[i]; const lin=(sy*W+sx)*3; outFlat[lin]=recSorted[i*3]; outFlat[lin+1]=recSorted[i*3+1]; outFlat[lin+2]=recSorted[i*3+2]; }
    putImageDataRGB(outC,outFlat,W,H);
    const tmp=document.createElement('canvas'); putImageDataRGB(tmp,outFlat,W,H); lastRecoveredBlob=await new Promise(res=>tmp.toBlob(res,'image/png'));
    infoL.textContent=`Decoded preview • ${W}×${H} (${N.toLocaleString()} px)`; infoR.textContent=`Ciphertext ${ct.length.toLocaleString()} bytes`; downloadDecBtn.classList.remove('hidden');
  } catch(e){ if(e.message!=='cancelled') infoL.textContent='Decode error: '+e.message; }
  finally{ setProgress(0,'Idle'); setETA(0); running=false; }
}
function downloadRecovered(){ if(!lastRecoveredBlob) return; const a=document.createElement('a'); a.href=URL.createObjectURL(lastRecoveredBlob); a.download='recovered.png'; a.click(); }

/* ---------- analyzer ---------- */
async function analyze(){
  if(!currentSrcFile() && !currentTgtFile()){ analysis.textContent='Select at least Source or Target.'; return; }
  const srcImg = currentSrcFile() ? await loadImageViaReader(currentSrcFile()) : null;
  const tgtImg = currentTgtFile() ? await loadImageViaReader(currentTgtFile()) : null;

  let baseW, baseH;
  if(baseSel.value==='source'){ if(!srcImg){ analysis.textContent='Set Output base to an image you loaded.'; return; } baseW=srcImg.naturalWidth; baseH=srcImg.naturalHeight; }
  else { if(!tgtImg){ analysis.textContent='Set Output base to an image you loaded.'; return; } baseW=tgtImg.naturalWidth; baseH=tgtImg.naturalHeight; }

  const limitMB=Math.max(2, Number(payloadLimitInp.value||16));
  const Ntarget=(limitMB*1024*1024)/4; 
  const scale=Math.sqrt(Ntarget/(baseW*baseH));
  const recommendedMaxSide=Math.max(64, Math.floor(Math.max(baseW,baseH)*scale));
  const outW=Math.round(baseW*scale), outH=Math.round(baseH*scale);
  const estMB=(Math.max(1,outW*outH)*4/1024/1024).toFixed(2);

  analysis.innerHTML = `Output base: <span class="pill">${baseW}×${baseH}</span> → Suggested Max Side <span class="pill">${recommendedMaxSide}px</span> `
    + `(approx output ${outW}×${outH}, payload ≈ ${estMB} MB).`;
  maxSideInp.value = recommendedMaxSide;
}

/* ---------- auto-preview debounce ---------- */
let autoTimer=null; function scheduleAutoPreview(delay=0){ if(autoTimer) clearTimeout(autoTimer); autoTimer=setTimeout(()=>{ if(!running && currentSrcFile() && currentTgtFile()) doPreview(); }, delay); }

/* ---------- swap roles ---------- */
function swapRoles(){
  [srcBlob, tgtBlob] = [tgtBlob, srcBlob];
  // optionally flip base selector to preserve semantics
  if(flipBaseChk.checked){ baseSel.value = (baseSel.value==='source') ? 'target' : 'source'; }
  // refresh preview without touching the file inputs
  infoL.textContent='Swapped Source ⇄ Target.'; infoR.textContent='';
  scheduleAutoPreview(50);
}

/* ---------- wire ---------- */
previewBtn.addEventListener('click', doPreview);
encodeBtn.addEventListener('click', doEncode);
previewDecBtn.addEventListener('click', doPreviewDecode);
downloadDecBtn.addEventListener('click', downloadRecovered);
analyzeBtn.addEventListener('click', analyze);
srcFile.addEventListener('change',()=>{ srcBlob = (srcFile.files && srcFile.files[0]) || null; scheduleAutoPreview(150); });
tgtFile.addEventListener('change',()=>{ tgtBlob = (tgtFile.files && tgtFile.files[0]) || null; scheduleAutoPreview(150); });
swapBtn.addEventListener('click', swapRoles);

// keyboard: X to swap
window.addEventListener('keydown',(e)=>{ if(e.key && e.key.toLowerCase()==='x'){ e.preventDefault(); swapRoles(); }});
</script>
  
<!-- Help dialog (loads only when opened) -->
<dialog id="helpDlg" style="max-width:720px;border:1px solid #2a2b36;border-radius:14px;background:#0f1017;color:#e8e8f0;padding:0;">
  <header style="display:flex;justify-content:space-between;align-items:center;padding:12px 14px;border-bottom:1px solid #20202a">
    <strong>How to use</strong>
    <button id="helpClose" class="iconbtn" aria-label="Close">✕</button>
  </header>
  <div style="padding:14px 16px;display:grid;gap:10px;font-size:13px">
    <div><b>1)</b> Pick <i>Source</i> (keeps colors) and <i>Target</i> (guides layout). Adjust <i>Canvas From</i> and <i>Fit</i> if needed.</div>
    <div><b>2)</b> Click <b>Preview</b> to see the morph. Use <b>Max Side</b> to control output size and payload.</div>
    <div><b>3)</b> Choose <b>Guide Mode</b>:
      <ul style="margin:6px 0 0 16px">
        <li><b>Tone</b> — orders by brightness/edges from the target.</li>
        <li><b>Mask</b> — orders by a thresholded shape (set <b>Mask Color</b> and <b>Threshold</b>).</li>
      </ul>
    </div>
    <div><b>4)</b> To export a camo PNG: set a <b>Password</b> → <b>Encode & Download</b>.</div>
    <div><b>5)</b> To recover: choose the PNG under <b>Decode</b>, enter password → <b>Preview Decode</b> → <i>Download Recovered</i>.</div>
    <hr style="border:none;border-top:1px solid #20202a">
    <div><b>Swap</b>: Use <b>↔ Swap</b> (or press <b>X</b>). Optionally enable <b>Flip Output base too</b> to keep semantics.</div>
    <div><b>Tips</b>: 
      <ul style="margin:6px 0 0 16px">
        <li><b>Contain</b> keeps full target with letterbox; <b>Cover</b> fills frame.</li>
        <li>Higher <b>Max Side</b> → bigger payload; use <b>Analyze</b> to get a safe size.</li>
      </ul>
    </div>
    <div><b>Shortcuts</b>: <code>X</code> swap, <code>H</code> help, <code>P</code> preview, <code>E</code> encode.</div>
  </div>
</dialog>

<script>
  const helpBtn=document.getElementById('helpBtn');
  const helpDlg=document.getElementById('helpDlg');
  const helpClose=document.getElementById('helpClose');
  function openHelp(){ if(typeof helpDlg.showModal==='function'){ helpDlg.showModal(); } else { alert('Open the ? help for quick steps.'); } }
  helpBtn?.addEventListener('click', openHelp);
  helpClose?.addEventListener('click', ()=>helpDlg.close());
  window.addEventListener('keydown', (e)=>{ const k=e.key&&e.key.toLowerCase(); if(k==='h'){ e.preventDefault(); openHelp(); } else if(k==='p'){ if(document.activeElement.tagName!=='INPUT') { e.preventDefault(); document.getElementById('previewBtn').click(); } } else if(k==='e'){ if(document.activeElement.tagName!=='INPUT') { e.preventDefault(); document.getElementById('encodeBtn').click(); } }});
</script>
</body>
</html>
